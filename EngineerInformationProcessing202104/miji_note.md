# :star:2021 정처기 실기 정리 노트:star:

## 👉목차👈

⚡️[PART 04 데이터 입출력 구현](#part-04-데이터-입출력-구현)

⚡️[PART 06 서버 프로그램](#part-06-서버-프로그램)

⚡️[PART 09 SQL 응용](#part-09-sql-응용)

⚡️[PART 11 프로그래밍언어 활용](#part-11-프로그래밍언어-활용)

⚡️[PART 12 응용 SW 기초기술 활용](#part-12-응용-sw-기초기술-활용)

<hr>

## PART 04 데이터 입출력 구현

> P1-305~307 참고

91. #### 데이터베이스에서 이상현상이란?

<details> <summary>답</summary> <div markdown="1">  


  ```
정규화를 거치지 않으면 데이터베이스의 데이터들이 불필요하게 중복되어 릴레이션 조작 시 문제가 발생하는 현상
  ```

  ##### 해설

추가개념: 이상현상 종류

- **삽입 이상**: 테이블에 데이터를 삽입할 때, 의도와는 관계없이 원하지 않는 값들로 인해 삽입할 수 없는 현상
- **수정(갱신) 이상**: 테이블에서 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상
- **삭제 이상**: 테이블에서 한 튜플을 삭제할 때, 의도와는 관계없이 값들도 함께 삭제되면 연쇄삭제가 일어나는 현상

</div> </details>

93. #### 데이터베이스에서 정규화 개념?

<details> <summary>답</summary> <div markdown="1">  


  ```
  데이터베이스 이상현상의 원인이 되는 데이터 중복성을 제거하여 데이터의 무결성을 보존하는 기법
  ```

</div> </details>

94. #### 함수종속성이란?

<details> <summary>답</summary> <div markdown="1">  


  ```
 하나의 릴레이션을 구성하는 속성들의 부분 집합을 X와 Y라 할 때, 어느 시점에서든 릴레이션 내의 모든 튜플(행)을 대상으로 한 X 값에 대한 Y 값이 항상 하나면 "X가 Y를 함수적으로 결정한다"
  ```

  ##### 해설

    X -> Y로 표현, Y는 X에 종속된다고 함.

</div> </details>

96. #### 괄호 안에 들어갈 말은?

(): 릴레이션 R이 제1정규형이고, 기본키가 아닌 속성이 기본키에 완전 함수 종속성일 때 정규화 과정<br>

(): 릴레이션 R이 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키 일 때 정규화 과정

<details> <summary>답</summary> <div markdown="1">  


  ```
제2정규화, 보이스/코드 정규화
  ```

  ##### 해설

- 추가개념: 정규화 유형

| 유형                     | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 제1정규화                | 릴레이션 R의 모든 속성 값이 원자값을 가지는 릴레이션         |
| 제2정규화                | 릴레이션 R이 제1정규형이고, 기본키가 아닌 속성이 기본키에 완전 함수 종속성일 때 정규화 과정(**부분 함수 종속 제거**) |
| 제3정규화                | 릴레이션 R이 제2정규형이고 기본키가 아닌 속성이 기본키에 비이행적 non-transitive으로 종속할 때(직접 종속), (**이행 함수 종속 제거**) |
| 보이스/코드 정규화(BCNF) | 릴레이션 R에서 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키 일 때(**결정자가 후보키가 아닌 함수종속 제거**) |
| 제4정규화                | 릴레이션 R의 모든 속성 X에 대해 A->X이고 A가 후보키일때(**함수종속이 아닌 다치종속 제거**) |
| 제5정규화                | 릴레이션 R에 존재하는 모든 조인 종속이 R의 후보키를 통해 성립되면 R은 5NF(**후보키를 통하지 않은 조인종속 제거**) |

</div> </details>



100. #### 데이터베이스에서 CRUD Matrix의 개념과 점검 기술 서술

<details> <summary>답</summary> <div markdown="1">  
- 개념 : 프로세스와 엔티티의 상관관계를 이용하여 구축된 엔티티 관계도를 검증 도구
- 점검 기준: 
  - 모든 엔티티에 CRUD가 한번 이상 표기되어야함
  - C와 R이 각각 한번 이상 존재해야함
  - 모든 단위 프로세스가 하나 이상의 엔티티에 표기되어야함

</div> </details>



103. #### 추가 개념:

|  종류  | 설명                                                         |
| :----: | ------------------------------------------------------------ |
| 후보키 | - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 하나 또는 몇 개의 속성의 집합<br />- 유일성과 최소성을 모두 만족 |
| 기본키 | - 릴레이션의 유일한 식별자(유일성, 최소성 모두 만족)<br />- 기본키로 지정된 속성은 같은 값을 가지지 못함<br />- 후보키 중에서 선정된 키로 중복값을 가질 수 없음<br />- 외래키로 참조 가능, not null, unique |
| 대체키 | - 후보키가 둘 이상 되는 경우에 기본키로 선택되지 못한 후보키들<br />- 후보키 = 기본키 + 대체키 |
| 슈퍼키 | - 유일성만 있고 최소성이 없는 속성의 집합                    |
| 외래키 | - 한 테이블의 키 중 다른 테이블의 튜플을 식별할 수 있는 키   |

105. #### 추가개념:

<details> <summary>답</summary> <div markdown="1">  

  ```
  회원식별구분값, 카드 매체 구분, 프로모션구분
  ```

  ##### 해설
    공통 코드화란? 모든 업무에서 표준 규칙에 의해 동일하게 구분되는 코드값을 의미하며, 공통 코드를 하용함으로서 데이터의 형식과 값의 일관성이 유지되는 이점을 가짐

</div> </details>

107. 다음이 설명하고 있는 기법은?

```
- 어떤 정해진 속성(컬럼) 값을 기준으로, 동일한 값을 가진 하나 이상의 테이블의 튜플(행)를 같은 장소에 저장하는 물리적인 기법
- 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용되는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 방법
```

<details> <summary>답</summary> <div markdown="1">  
  ```
  클러스터
  ```

  ##### 해설

    클러스터 장점:
    - 그룹된 컬럼 데이터 행들이 같은 데이터 Block에 저장되기 때문에 디스크 I/O를 줄여줌
    - 클러스터된 테이블 사이에 조인이 발생할 경우 그 처리 시간 단축
    - 클러스터 키 열을 공유하여 한번만 저장하므로 저장 영역의 사용을 줄여줌

</div> </details>



108. #### 파티셔닝이란?

<details> <summary>답</summary> <div markdown="1">  

  ```
검색 연산의 최적화를 위해 데이터베이스 내의 튜플(행)들에 대한 정보를 구성하는 데이터 구조
  ```

  ##### 추가 개념

파티셔닝 범위

| 범위                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| Range partitioning     | - 연속적인 숫자나 날짜 기준으로 파티셔닝<br />- 손쉬운 관리 기법 제공에 따른 관리 시간을 단축 |
| Composite partitioning | - 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산<br />- Range 파티셔닝 결과 생성된 파티션이 너무 커서 효과적으로 관리할 수 없을 때 유용<br />- List와 Hash 파티셔닝 결합하여 사용 |
| Hash partitioning      | - 파티션 키의 해쉬값에 의한 파티셔닝<br />- 조회 시 조건과 무관하게 병령 Degree 제공<br />- 특정 데이터가 해쉬 파티션에 있는지 판단 불가<br />- 해쉬 파티션은 파티션을 위한 범위가 없는 데이터에 적합 |
| List partitioning      | - 특정 파티션에 저장될 데이터에 대한 명시적 제어 가능<br />- 분포도가 비슷하며, 많은 SQL에서 해당 컬럼의 조건이 많이 들어오는 경우 유용 |

</div> </details>

109. #### 인덱스란?

<details> <summary>답</summary> <div markdown="1">  

  ```
  검색 연산의 최적화를 위해 데이터베이스 내의 튜들에 대한 정보를 구성하는 데이터 구조
  ```

</div> </details>

110. #### 인덱스 설계서 기반으로 사원 아이디와 사원이름의 컬럼을 포함한 인덱스 생성 구문 작성

- 테이블명: EMP
- 인덱스명: EMP_IX_01
- 컬럼명 : EMP_ID, EMP_NM
- 데이터타입: NUMBER, VARCHAR2(16)

<details> <summary>답</summary> <div markdown="1">  


  ```
  CREATE INDEX EMP_IX_01 ON EMP(EMP_ID, EMP_NM);
  ```

##### 해설

```
인덱스 생성 구문: CREATE [UNIQUE] INDEX <index_name> ON <table_name> (<columns>);
```

</div> </details>



111. #### 데이터베이스에서 뷰의 개념은?

<details> <summary>답</summary> <div markdown="1">  


  ```
  사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상의 테이블
  ```

</div> </details>

112. #### 뷰 설계서 기반으로 뷰 생성 구문

- 뷰 명: VW_EMP
- 테이블 명: EMP
- 컬럼명: EMP_ID, EMP_NM
- 데이터타입: NUMBER, VARCHER2(16)

<details> <summary>답</summary> <div markdown="1">  


  ```
  CREATE VIEW VW_EMP AS SELECT EMP_ID, EMP_NM FROM EMP
  ```

</div> </details>

113. #### 데이터베이스에서 관계의 유형

1. _ 관계는 개체 집합 A의 각 원소가 개체 집합 B의 원소 한개와 대응하는 관계
2. _ 관계는 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
3. _ 관계는 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계

<details> <summary>답</summary> <div markdown="1">  


  ```
 1. 일대일 2. 일대다 3. 다대다
  ```

</div> </details>

114. #### 데이터베이스에서 슈퍼/서브타입 관계의 개념 서술

<details> <summary>답</summary> <div markdown="1">  


  ```
여러 엔티티에서 공통 속성이 존재할 경우 속성들을 하나로 묶어 통합하는 데이터 모델링 기법
  ```

##### 해설

```
슈퍼타입은 상위 공통 데이터의 내용을 담는 타입, 서브타입은 하위 분할된 정보를 담는 타입
```

</div> </details>

116. #### 다음 보기에서 설명하는 데이터베이스는?

```
- 하나의 데이터베이스 관리 시스템(DBMS)이 여러 CPU에 연결 된 저장장치들을 제어하는 형태의 데이터베이스
- 논리적으로 같은 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리전으로 분산되어 있는 데이터들의 모임
- 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 노드로 위치시켜 사용성/성능 등을 극대화시킨 데이터베이스
```

<details> <summary>답</summary> <div markdown="1">  


  ```
분산 데이터베이스
  ```

</div> </details>

107. _은 사용하려는 데이터의 저장 장소 명시 불필요. 위치 정보가 시스템 카탈로그에 유지되어야 한다.

<details> <summary>답</summary> <div markdown="1">  


  ```
위치 투명성
  ```

##### 해설

분산 데이터베이스의 투명성

- 분할 투명성(단편화): 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 사이트에 저장
- 위치 투명성: 사용하려는 데이터의 저장 장소 명시 불필요. 위치 정보가 시스템 카탈로그에 유징되어야 함
- 지역사상 투명성: 지역 DBMS와 물리적 DB사이의 매핑 보장. 각 지역 시스템 이름과 무관한 이름 사용 가능
- 중복 투명성: DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
- 장애 투명성: 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
- 병행 투명성: 다수 트랜잭션 동시 수행 시 결과의 일관성 유지, Time Stamp, 분산 2단계 로킹을 이용 구현

</div> </details>


<hr>

## PART 06 서버 프로그램

134. #### 다음을 가리키는 용어는?

```
프로그램 개발에 관련된 모든 작업을 하나의 프로그램에서 처리하는 환경을 제공하는 소프트웨어
```

답: IDE

- 추가 개념:
  - Eclipse: JAVA, JSP
  - Visual Studio: C++, C#, .net
  - IntelliJ: JAVA, Kotlin, Go
  - Xcode: Objective-c, swift



135. #### 추가개념: 형상관리 소프트웨어의 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경사항을 관리하기 위한 활동



136. #### 추가개념: GIT - 컴퓨터 파일의 변경사항을 추적하고, 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 형상관리 시스템



137. #### 추가 개념: CI - 지속적인 통합이라는 뜻으로, 여러 사람이 형상관리 도구에 저장한 내용들을 다운받고, 빌드하고, 테스트하는 일련의 작업을 특정 시점이 아닌, 지속적으로 수행하는 것을 말함.

140. #### 코드 빈칸 채우기

```java
class Parent{
  int a;
  public Parent(int a){
    (1).a = a;
  }
}
  class Child (2) Parent{
    public Child(int a){
      (3).(a); //부모 클래스인 Parent의 생성자 중에서 파라미터가 없는 default 생성자가 없음 ->직접 부모의 생성자를 호출해주어야함
      (3).display();
    }
  }
public class Test{
  public static void main(String[] args){
    Child a = (4) Child(10);
  }
}
```

답: this, extends, **super**, new

142. #### 추가개념: 인터페이스의 특징

- 멤버변수를 가질 수 없음
- 함수 선언만 가능, 구현 불가
- 자체로 객체 생성 불가

143. #### 추가개넘: abstract

- 추상 메소드는 선언만 있고, 구현 부분이 없는 메소드로 선언 시 'abstract' 키워드 필요

144. #### & 145 -> Overriding VS Overloading

| Overriding(오버라이딩)                                       | Overloading(오버로딩, 다중정의)                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - **상속 관계**ㅇㅔ 있는 두 클래스에서 메소드를 하위 클래스에서 재정의<br />- 슈퍼클래스 메소드 무시하기 혹은 덮어쓰기<br />- 메소드 이름 동일, 파라미터 개수 및 데이터 타입 동일, 리턴 타입 동일<br />- 접근 제한자: 하위 메소드의 접근 범위가 상위 메소드의 접근 범위보다 넓가나 같아야 함<br />- 예외 처리: 예외 발생 시 같은 예외 형식이거나,  더 구체적인 예외 형식이어야 한다. | - 메소드를 같은 클래스에서 정의<br />- 메소드 이름 동일, 파라미터 개수 및 데이터 타입 동일, 리턴 타입이 다를 수 있음<br />- 접근 제한자: 상관없음<br />- 예외 처리: 관계 없음 |

147. #### 접근제한자

- public: 모든 범위
- protected: 상속 관계 또는 동일 패키비
- 없을 때: 동일 패키지
- private: 동일 클래스

148. 추가 개념: 객체지향에서 캡슐화는 추상화한 객체를 변수와 함수로 묶어 클래스를 만드는 것을 의미, 정보은닉은 접근제한자를 통해 변수, 함수에 대한 외부접근을 제한

152. #### 아래 코드는 정렬 알고리즘 중 어떤 알고리즘?

```java
class Test{
  static void align(int a[]){
    int temp;
    for(int i=0; i<4; i++){
      for(int j=0; j<4-i; j++){
        if(a[j] = a[j+1]){
          temp = a[j];
          a[j] = a[j+1];
          a[j+1] = temp;
        }
      }
      for(int x = 0; x<5; x++){
        System.out.print(a[x]+" "); //i가 1일때 출력값은?
      }
      System.out.print("₩n");
    }
  }
  public static void main(String[] args){
    int a[] = {7,4,5,1,3};
    align(a);
  }
}
```

답: 버블 정렬(교환 정렬), 4,1,3,5,7

- 추가개념:

  - 버블정렬: 앞의 값이 뒤의 값보다 크다면 둘의 자리를 바꿈

    > P1-406 풀이 참고

154. #### 아래 코드는 정렬 알고리즘 중 어떤 알고리즘?

```java
class Test{
  static void sort(int[] a){
    int n = a.length;
    
    for(int i=0; i<n-1; i++){
      int idxLeast = i;
      
      for(int j=i+1; j<n; j++){
        if(a[j] < a[idxLeast]){
          idxLeast = j;
        }
      }
      
      if(idxLeast != i){
        int tmp = a[i];
        a[i] = a[idxLeast];
        a[idxLeast] = tmp;
      }
      
      for(int x=0; x<a.length; x++){
        System.out.print(a[x] + " "); //i=2일때?
      }
      System.out.print("₩n₩n");
    }
  }
  public static void main(String[] args){
    int a[] = {7,4,5,1,3};
    sort(a);
  }
}
```

답: 선택 정렬 알고리즘 -> 최소값(a[idxLeast])을 찾아서 저장, i와 idxLeast 자리 교환하면서 비교 정렬

- **최솟값을 저장하는 알고리즘은 선택 정렬 알고리즘밖에 없음**

> 추가 설명 p1-411 참고!

156. #### 아래 코드

```java
class Test{
  static void sort(int[] a){
    int n = a.length;
    
    for(int i=1; i<n; i++){
      int key = a[i];
      int j = i-1;
      
      while(j >=0 && a[j] > key){
        a[j+1] = a[j];
        j--;
      }
      a[j+1] = key;
      
      for(int x=0; x<a.length; x++){
        System.out.print(a[x]+" ");
      }
      System.out.print("₩n")
    }
  }
  public static void main(String[] args){
    int[] a={7,4,5,1,3};
    sort(a);
  }
}
```

답: 삽입 정렬 알고리즘

- 추가개념: key값을 저장하여 배열 앞부분부터 비교하여 shift, 저장 반복



166. #### C 코드의 출력 결과는?

```java
int main(){
  int a = 7;
  int b = 5;
  
  int x = a & b;//0101
  int y = a | b; //0111
  int z = a ^ b; //XOR => 0 1 0 0(두 비트가 같으면 0, 다르면 1)
  
  print("%d %d %d", x,y,z);
  return 0;
}
```

풀이: 7 = 0 1 1 1, 5 = 0 0 1 1  



167. #### 다음 코드 출력 결과

```c
int main(){
  int c = 1;
  
  switch(3){ //case3으로 가라는 의미
    case 1: c+=3;
    case 2: c++;
    case 3: c = 0; //여기서 부터 시작해 break만날때 까지 순차적으로 실행
    case 4: c+=3;
    case 5: c-=10;
     break;
    case 6: c++;
    default: c--;
  }
  print("c: %d", c);
  return 0;
}
```

답: 0 + 3 - 10 ->break, -7!



177. #### 3개의 파이썬 파일에서 출력결과는 모두 동일하게 출력될 때 1,2번에 들어갈 코드 채우기

```python
//a.py
import math
print ("pi is", math.pi)

//b.py
import math as m
print('pi is', (1))

//c.py
from math import pi
print('pi is', (2))

//출력값
pi is 3.14156~~~
```

답: m.pi, pi

- 추가 개념:
- import math as m -> math라는 라이브러리를 가져와 m이라는 별칭으로 가져와서 m으로 접근
- from math import pi ->math 라이브러리에서 pi만 가져와서 참조없이 바로 사용 가능



180. #### 코드 출력 결과

```python
a = list(range(1,6,2))# 1부처 6-1까지의 범위의 숫자를 2 간격 range 객체 생성해서 리스트로 바꿈 ->[1,3,5]
a.append(10) #10 추가
a.remove(1) #가장 먼저 발견되는 1 제거

for x in a:
	print(x, end = ' ')
```

딥: 3 5 10



181. #### 코드 출력 결과

```python
a = ('한국','중국','일본')

print(a[0]) #한국
print(a[1:]) #중국, 일본

a[1]='미국'
print(a) #에러 발생 -> 튜플에서 추가,삭제,변경 등이 불가능한 읽기 전용이기 때문
```

182. #### 코드 출력 내용

```python
a = {'사과','배','딸기'} #집합 ->중복 허용 안됨, 순서 없음
a.add('수박') #사과, 배, 딸기, 수박
a.add('배') #사과,배,딸기,수박
a.remove('사과') #배,딸기,수박
a.update({'포도','딸기','귤'}) #배,딸기,귤,수박,포도

print(a)
```

답: {'배','딸기','귤','수박','포도}



## PART 09 SQL 응용

242. #### 알맞은 SQL 유형은?

- _ : 데이터베이스에 저장된 데이터를 수정,삭제, 추가하는 명령어(INSERT, UPDATE, DELETE)
- _ : 데이터베이스 객체를 생성하고 수정, 삭제하는 명령어(CREATE,ALTER, DROP, TRUNCATE)

<details> <summary>답</summary> <div markdown="1">  

  ```
  데이터 조작어(DML), 데이터 정의어(DDL)
  ```

##### 해설(추가 개념)

```
- 데이터 질의어(DQL): 데이터베이스에 저장된 데이터를 검색하는데 사용하는 질의어(SELECT)
- 데이터 제어어(DCL): 데이터베이스의 규정이나 기법을 정의하고 제어하는 언어(GRANT, REVOKE, COMMIT, ROLLBACK)
```

</div> </details>

243. #### 알맞은 유형의 명령어는?

     1. DML, 테이블 특정행 삭제, 저장 공간 반납 안됨, 롤 백 가능, 작업속도 느림

     2. DDL, 테이블의 모든 행 삭제, 저장 공간 반납, 롤 백 불가, 작업속도 빠름


<details> <summary>답</summary> <div markdown="1">  

  ```
1. DELETE 2. TRUNCATE
  ```

##### 해설(추가 개념)

```
- DELETE: 데이터가 삭제된 이력이 로그에 적재되어 회복 가능
- TRUNCATE: 테이블의 전체 데이처를 이력을 쌓지 않고 삭제되기 때문에 회복이 불가능한 반면 삭제 속도는 빠름
```

</div> </details>

245. #### 사원 테이블(EMPLOYEE)에서 부서번호(dno) 종류를 검색하는 SELECT문은?

<details> <summary>답</summary> <div markdown="1">  

  ```mysql
SELECT DISTINCT DNO FROM EMPLOYEE;
  ```

##### 해설(추가 개념)

```
DISTINCT는 테이블의 검색 결과 데이터 중에 중복된 컬럼을 제외하고자 할 때 사용됨
```

</div> </details>

246. #### 사원(EMPLOYEE) 테이블에서 이름(EMPNAME)의 가운데가 '상'인 사원의 이름과 급여를 검색하는 SELECT 문을 작성

<details> <summary>답</summary> <div markdown="1">  

  ```mysql
SELECT EMPNAME, SALARY FROM EMPLOYEE WHERE EMPNAME LIKE '%상%';
  ```

##### 해설(추가 개념)

```
- LIKE '이%': '이'로 시작하는 이름들 검색
- LIKE '_길동': 길동으로 끝나는 이름들 검색
- LIKE '[김이]': 김 또는 이로 시작하는 이름들 검색
```

</div> </details>

248. #### 부서번호(DNO)가 1번에 속한 사원들의 이름과 급여를 검색한 결과를 급여가 높은 순서대로 정렬

<details> <summary>답</summary> <div markdown="1">  


  ```mysql
SELECT SALARY FROM EMPLOYEE WHERE DNO=1 ORDER BY SALARY DESC;
  ```

##### 해설(추가 개념)

```
ORDER	명령어를 이용해 검색 결과를 오름차순(ASC) 또는 내림차순(DESC)로 정렬 가능
```

</div> </details>

250. #### 추가 개념

| 집계함수   | 설명                                   |
| ---------- | -------------------------------------- |
| COUNT()    | 튜플(행)이나 값들의 개수 -> 널값 포함! |
| SUM()      | 값들의 합                              |
| AVG()      | 값들의 평균값                          |
| MAX()      | 값들의 최대값                          |
| MIN()      | 값들의 최소값                          |
| STDDEV()   | 값들의 표준편차값                      |
| VARIANCE() | 값들의 분산값                          |

ex) SELECT COUNT(*) FROM 학생;

251. INSERT문 작성(학생 테이블)

```
이름: 황진이, 학번: 20005, 전화번호: 345-6789, 국어점수:90, 수학점수:95
```

<details> <summary>답</summary> <div markdown="1">  


  ```mysql
INSERT INTO 학생(이름,학번, 전화번호, 국어점수, 수학점수) VALUES(황진이, 20005, 345-6789, 90, 95);
  ```

##### 해설(추가 개념)

```mysql
테이블에 새로운 튜플을 한 번에 여러 개씩 삽입하고자 하면 INSERT문에 서브쿼리 이용
-VALUES 대신 SELECT 절 기술
ex) INSERT INTO 테이블명(컬럼1, 컬럼2....)
SELECT절
```

</div> </details>

252. #### 학생 테이블에서 전공과목의 국어 점수가 90점 이하인 데이터를 삭제하는 쿼리문

<details> <summary>답</summary> <div markdown="1">  


  ```mysql
DELETE FROM 학생 WHERE 전공과목 = '국어' AND 점수 <=90;
  ```

</div> </details>

253. #### 학생 테이블에서 학번이 1236이고 전공과목이 영어인 학생의 점수를 100으로 수정하는 쿼리문

<details> <summary>답</summary> <div markdown="1">  


  ```mysql
UPDATE 학생 SET 점수=100 WHERE 학번='1236'AND 전공과목='영어'
  ```

</div> </details>

254. #### 사원 테이블 생성문

<details> <summary>답</summary> <div markdown="1">  


  ```mysql
CREATE TABLE EMPLOYEE(
 EMPNO NUMBER NOT NULL,
 EMPNAME VARCHAR2(20),
 SALARY NUMBER,
 DNO NOT NULL
);
  ```

</div> </details>

<hr>

## PART 11 프로그래밍언어 활용

356. #### 예상 출력값은?(파이썬, p2-219)

     ```python
     string = input(“7문자 이상 문자열을 입력")
     m = string[0:2] + string[-4:]
     print(m)
     입력값: Hello World
     ```

풀이: string[0:2] -> 인덱스 0부터 2까지 출력,string[-4:] ->뒤에서부터 4개 출력<br>

정답:Heorld<br>



357. #### 브라우저의 주소창에서 디렉토리 경로를 상위 경로로 임의로 이동하여 특정 디렉토리 내의 파일을 다운로드하는 공격기법은? (p2-220)

     답: 디렉토리 접근 공격<br>

     추가 개념:

     | 보안 취약점        | 보안 요구 항목                                               |
     | ------------------ | ------------------------------------------------------------ |
     | FTP 바운스 공격    | FTP 서버의 전송 목적지 주소를 임의로 지정하여 FTP 서버를 경유해 임의의 목적지로 메시지나 파일을 전송하는 공격 기법 |
     | SQL 삽입           | 공격자가 입력한 데이터에 대한 유효성을 점검하지 않아 SQL이 변경되어 정보의 유출 또는 DB의 변경을 가하는 공격기법 |
     | 버퍼 오버플로      | 메모리를 다루는 데 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점 |
     | 디렉토리 접근 공격 | 브라우저의 주소창에서 디렉토리 경로를 상위 경로로 임의로 이동하여 특정 디렉토리 내의 파일을 다운로드하는 공격 기법 |


358. #### 응집도 수준 가장 높은 응집도 이름은?

     - 답: 기능적 응집도
       - 추가 개념:
         - 응집도는 높을수록 좋고 결합력은 낮을수록 좋음
         - 응집도: 우논시절통순기(낮->높)

359. #### 자료 결합도란?

     - 답: 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 상호 작용이 일어나는 결합도를 의미
       - 추가 개념:
         - 결합도는 낮을수록 좋음!
         - 결합도: 자스제외공내(높->낮)

#### 수제비 개념:

- 데이터 타입의 유형: 불린, 문자, 문자열, 정수, 부동 소수점 타입(Floating point type),배열

- 파이썬에서 for문:

  ```python
  //range에 시작값과 끝값+1로 정의할 경우 끝값-시작값만큼 반복, 1씩 증가
  for 변수 in range (시작값, 끝값+1) :
  	명령문
  ```

  ```python
  //range에 반복횟수를 정의한 경우 0부터 반복횟수-1까지 변수가 1씩 증가
  for 변수 in range (반복횟수) :
  	명령문
  ```

실행하는 방식에 따른 언어 분류:

| 종류          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 명령형 언어   | - 컴퓨터에 저장된 명령어들이 순차적으로 실행되는 프로그래밍 방식<br />- 절차형 언어 <br>- ex) FORTRAN, COBOL, PASCAL, C |
| 객체지향 언어 | - 객체 간의 메시지 통신을 이용하여 프로그래밍하는 방식<br />- ex) JAVA, C++ |
| 함수형 언어   | - 수학적 수식과 같은 함수들로 프로그램을 구성하여 호출하는 방식<br />- ex) LISP |
| 논리형 언어   | - 논리 문장을 이용하여 프로그램을 표현하고 계산을 수행하는 개념에 기반한 프로그래밍 방식<br />- ex) 프롤로그 |

구현 기법에 따른 언어 분류:

| 종류                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 컴파일 방식의 언어     | - 고급 언어를 기계어로 번역하는 방식의 언어<br />- 컴파일러에 의해 필요한 정보가 미리 계산되어 실행 속도가 높음<br />- *컴파일러: 고급 언어를 기계어로 번역하는 프로그램이자 도구*<br />- ex) FORTRAN, PASCAL, C, C++ |
| 인터프리터 방식의 언어 | - 고급 언어 명령문을 하나씩 번역하고 실행하는 방식의 언어<br />- 프로그램 실행과 동시에 동작<br />- ex) BASIC, 프롤로그, LISP |
| 혼합형 방식의 언어     | - 고급 언어를 컴파일하여 중간 언어로 변환한 후, 인터프리터에 의해 번역을 실행하는 방식의 언어<br />- ex) 자바 |

- 절차적 프로그래밍 언어 종류: 알골, C언어, 베이직, FORTRAN
- 객체지향 프로그래밍 언어 종류: C++, C#, JAVA, 델파이
- 스크립트 언어 종류: 파이썬, php, 펄, 자바스크립트

<br>

객체지향 프로그래밍의 구성 요소:

1. 객체(object)
2. 클래스
3. 메시지: 객체 간의 통신

<br>

객체의 구성요소:

1. 개체(entity)
2. 속성(attribute)
3. 메서드(method)

<br>

- 라이브러리란? 효율적인 프로그램 개발을 위해 필요한 프로그램을 모아 놓은 집합체
  - 구성: 도움말, 설치파일, 샘플 코드



- 모듈 vs 패키지
  - 모듈: 전역변수, 함수 등을 모아둔 파일
  - 패키지: 모듈을 디렉터리 형식으로 구조화한 라이브러리

<hr>

## PART 12 응용 SW 기초기술 활용

> p2-225~

360. #### 처리 중인 데이터나 처리 결과나 처리 결과를 임시 보관하는 기능을 하며 산술 연산이나 정보 해석, 전송 등을 할 수 있는 일정 길이의 정보를 저장하는 CPU 내부의 초고속 기억장치는?

- 답: 레지스터
- 추가 종류: 
  - PC(Program Counter): 다음 인출할 명령어 주소를 가지고 있는 레지스터
  - MAR(Memory Address Register): 메모리 주소를 일시적으로 저장하는 사용되는 레지스터
  - MBR(Memory Buffer Register): 기억장치에 쓰여질 데이터 혹은 기억장치로부터 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터
  - IR(Instruction Register): 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터
  - AC(Accumulator): 데이터나 연산결과를 일시적으로 저장하는 레지스터

364. #### 인터럽트 처리 루틴 순서

답: 인터럽트 인식->현재 상태 보존 -> 요청 인터럽트 서비스로 분기 및 서비스 -> 사용자 상태 복구 및 재개

365. #### 명령어 수행과정

답: 명령어 인출(IF) -> 명령어 해독(ID) ->명령어 실행(EX) ->데이터 저장(WB)

366. #### 프로세스가 실행되면서 특정 메모리 페이지를 일정 시간동안 집중적으로 액세스하는 현상?

- 답: Locality(구역성, 지역성, 국부성, 국소성)
- 추가 종류:
  - 시간 구역성: 최근에 액세스된 프로그램이나 데이터가 가까운 미래에. 다시 액세스 될 가능성이 높음
  - 공간 구역성: 기억장치 내 인접하여 저장된 데이터들이 연속적으로 액세스 될 가능성이 높음
  - 순차 구역성: 분기 하지 않은 한, 명령어들은 기억장치에 저장된 순서대로 인출되어 실행됨.

367. #### 인터럽트 체제 구현방식 중 소프트웨어에 의한 우선순위 구현방식은? 

답: 폴링(Polling) 방식

368. #### 입출력 장치 제어기가 CPU에 의한 프로그램의 실행 없이 자료의 이동을 하는 방식?

- 답: DMA(Direct Memory Access)
- 추가 개념:
  - Isolated I/O : IN, OUT 명령에 의해 주어진 I/O 포트에 입출력 기기가 접속되어 입출력 수행
  - Interrupt I/O : 데이터 전송을 마이크로컴퓨터의 인터럽트 기능을 가진 하드웨어에 의해서 제어하는 방식

369. #### 시스템 소프트웨어 중 실행 가능한 프로그램을 기억 장치로 적재하는 역할

- 답: 로더(Loader)
- 추가 개념(시스템 소프트웨어의 종류와 기능):
  - **운영 체제**: 하드웨어와 소프트웨어 자원 관리, 컴퓨터 프로그램을 위한 공통 서비스를 제공하는 프로그램
  - **어셈블러**: 어셈블리어를 기계어로 변환해주는 프로그램
  - **컴파일러**: 고급 언어를 기계어로 바꾸어 주는 프로그램
  - **인터프리터**: 고급 언어나 코드를 입력 받아 직접 기계어를 생성하여 실행해주는 프로그램
  - **전처리기**: 원시 프로그램을 번역하기 전에 미리 언어의 기능을 확장한 원시 프로그램을 생성하는 시스템 프로그램
  - **링커**: 서로 독립적으로 작성되고 번역된 목적 프로그램을 호출 및 연계시키는 시스템 프로그램
  - **로더**: 실행 코드를 주기억장치에 적재하여 실행 가능하도록 해주는 시스템 프로그램

370. #### 로더의 단계별 동작

답: Allocation(할당) -> Linking(링킹) -> Relocation(재배치) -> Loading(적재)

371. #### 로더의 종류 중 별도의 로더 없이 언어 번역 프로그램이 로더의 기능까지 수행하는 방식은?

- 답: 컴파일 즉시 로더

- 추가 개념:

| 배치 유형        | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 컴파일 즉시 로더 | - 가장 간단한 방법<br />- 번역기가 로더의 역할까지 담당<br />- 로더의 기능은 단순히 실행을 제어<br />- 어셈블러의 재번역 요구<br />- 서로 다른 언어로 작성된 모듈 간 연결 불가 |
| 절대 로더        | - 출력결과는 보조 기억장치에 저장<br />- 기계어 코드 프로그램에서 미리 지정한 번지에 프로그램과 데이터를 직접 적재<br />- 프로그래머가 어셈블러에게 적재주소 지정 |
| 재배치 로더      | - 적재 모듈을 주기억장치에 적재<br />- 상대주소를 절대주소로 변환<br />- 로드 과정에서 메모리의 적당한 영역을 찾아 로드 |
| 링킹 로더        | - 재배치 링크 및 적재를 한꺼번에 수행<br />- 두 단계 패스로 구성<br />   패스1. 모듈에 기억장소 할당, 외부 기호들의 주소 확정, 외부 기호표 작성<br />   패스2. 모든 상대주소를 절대주소로 변환, 외부 기호표 참조 후 적재 |
| 동적 로더        | - 재배치 로더와 링킹 로더의 단점 보완<br />- CPU가 현재 사용 중인 부분만 로드<br />- 미사용 중인 프로그램은 보조기억장치에 저장해 두는 방식<br />- 서브루틴들의 상호 호출관계 파악 |

376. #### UNIX에서 컴퓨터 내부를 관리하는 커널과 사용자 간의 인터페이스를 담당하며, 세션 별 변수 설정 등 사용자 지정 상태로 사용자가 요청한 명령어를 해석하는 기능을 하는 것은?

답: 쉘

377. #### 단위 시간 내에 하나 이상의 명령어를 중첩 수행하여 퍼포먼스를 향상시키는 멀티프로세스 환경에서의 명령어 처리 메커니즘을 무엇이라고 하는가?

- 답: 파이프라인 기법
- 추가 개념:

| 유형(파이프라인)                 | 설명                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| **단일**                         | 명령어 수행과정에서 각 단계를 한번만 중첩하여 다수의 동작을 동시에 수행하는 병렬처리 기술 |
| **수퍼**                         | 하나의 파이프라인을 여러 부분으로 나누어 연속적인 흐름과정으로 처리, 성능을 향상시키는 병렬처리 기술 |
| **Super** **Scalar**             | 프로세서 내에 파이프라인 된 ALU를 여러 개 포함하여 매 사이클마다 다수의 명령어들을 동시에 실행하는 병렬처리 기술 |
| **Super Pipelined Super Scalar** | 슈퍼스칼라 기법에 슈퍼 파이프라이닝 기법 적용                |
| **VLIW**                         | 동시에 수행될 수 있는 명령어들을 컴파일러 수준에서 추출, 하나의 명령어로 압축하여 수행하는 병렬처리 기술 |



378. #### Flynn의 컴퓨처 시스템 분류 제안 중에서 다수의 데이터 흐름이 다수의 프로세서들로 전달되며, 각 프로세서는 서로 다른 명령어를 실행하는 구조는?

- 답: 다중 명령어, 다중 데이터 흐름(MIMD, Multiple Instruction, Multiful Data Streams)
- 추가 개념(분류):
  - 단일명령어/단일 데이터흐름(SISD)
  - 단일명령어/다중 데이터 흐름(SMID)
  - 다중명령어/단일 데이터 흐름(MISD)
  - 다중명령어/다중 데이터 흐름(MIMD)

379. #### 운영체제 유형 중, 2개 이상의 프로그램을 주기억장치에 기억시키고 CPU를 번갈아 사용하면서 처리하여 컴퓨터 시스템 자원 활용률을 극대화하기 위한 프로그래밍 기법은?

- 답: 멀티 프로그래밍
- 추가 개념(운영 체제 유형별):

| 유형                                        | 개념                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| **다중 프로그래밍 시스템(멀티 프로그래밍)** | CPU의 효율을 극대화하기 위해 여러 개의 프로그램이 마치 동시에 실행되는 것처럼 처리하는 방식 |
| **시분할 시스템**                           | 프로세서 스케줄링과 다중 프로그래밍을 사용해 각 사용자에게 컴퓨터를 시간적으로 분할 사용 |
| **분산처리 시스템**                         | 시스템마다 운영 체제와 메모리를 가지고 독립적으로 운영되며 필요할 때 통신하는 시스템 |
| **다중처리 시스템**                         | 마이크로 프로세서 여러 개를 연결해 다중 프로세서를 생성      |
| **일괄처리 시스템**                         | 일정량의 데이터를 모아서 한꺼번에 일괄처리하는 방식          |
| **실시간처리 시스템**                       | 데이터에 대한 처리요구 발생 시 즉시 처리 응답                |

380. #### 중앙 컴퓨터와 직접 연결되어 응답이 빠르고 통신비용이 적게 소요되지만, 중앙 컴퓨터에 장애가 발생하면 전체 시스템이 마비되는 분산 시스템의 위상 구조는?

- 답: 성형 구조(star)
- 추가 개념(구조 분류):
  - **완전 연결 구조**: 모든 노드가 서로 연결됨
  - **부분 연결 구조** : 완전 연결보단 신뢰성 떨어지고 통신 속도가 늦음
  - **계층 구조**: 트리 형태로 구성
  - **성형 구조** : 중심 노드는 타 노드와 연결, 타 노드는 상호간 연결되지 않는 방식
  - **환형 구조(ring)**: 단방향, 양방향 통신 존재
  - **다중 접근 버스 구조**: 공유되는 하나의 버스 존재

> 381 문제 p2-252 참고!!

382. #### 가상기억장치 구현에서 고정되게 분할한 용량(페이지)을 주기억장치에 사상시키는 기법?

답: 페이징 기법

- 추가 개념: 세그멘테이션 기법 -> 가상기억장치 내의 프로그램과 데이터를 각 세그먼트가 주기억장치에 적재될 때마다 필요한 서로 다른 크기의 세그먼트로 분할

383. #### 운영체제의 운영 기법 중 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식?

답: 다중 처리 시스템(**379번 참고!!**)

384. #### 물리적인 메모리 용량보다 더 큰 용량의 프로그램을 실행할 수 있도록 보조 기억 장치 용량에 해당하는 용량만큼 메모리 용량을 확장하여 사용할 수 있도록 하는 기법은?

<details> <summary>답</summary> <div markdown="1">  


  ```
가상 메모리/가상 기억장치, Virtual Memory(VM)
  ```

</div> </details>

385. #### OS의 가상기억장치 관리에서 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합을 의미하는 것으로 스래싱(Thrashing)을 방지하는 기법은?

<details> <summary>답</summary> <div markdown="1">  


  ```
워킹세트(Working set)
  ```

</div> </details>

386. #### 연속된 데이터 또는 명령어들을 기억장치 모듈에 순차적으로 번갈아 가면서 처리하는 방식은?

<details> <summary>답</summary> <div markdown="1">  


  ```
메모리 인터리빙, 기억 장치 끼워넣기
  ```

</div> </details>

387. 메모리의 페이지 교체기법 중 가장 오랫동안 사용되지 않을 페이지를 교체기법은?

<details> <summary>답</summary> <div markdown="1">  


  ```
LRU(Least Recently Used System), 최저 사용 빈도
  ```

##### 해설(추가 개념)

페이지 교체 알고리즘:

| 구분                                                    | 내용                                                         | 특징                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **무작위 페이지 교체<br />/Random Page Replacement**    | 특별한 사용자에게 차이를 ㄷ지 않고 교체할 페이지를 무작위로 선정해 교체하는 기법 | 오버헤드가 적고 바로 뒤에 참조될 페이지도 교체 가능          |
| **FIFO/선입선출**                                       | 메모리에 올라온 지 가장 오래된 페이지를 교체                 | 선입선출 이상현상 발생: 프로세스에 더 많은 페이지를 할당할 경우 더 많은 페이지 부재가 발생하는 현상 |
| **OPR/최적 페이지 교체<br />/Optimal Page Replacement** | 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체        | FIFO의 모순을 해결, 구현이 비현실적                          |
| **LRU/최저 사용 빈도<br />/Least Recently Used**        | 가장 오랫동안 사용되지 않을 페이지 교체                      | 호출시간을 기록해야 하는 오버헤드 발생하나 효율적            |
| **LFU/최소 사용 빈도<br />/Least Frequently Used**      | 사용빈도가 가장 적은 페이지를 교체하는 기법                  | 구역성 문제 발생                                             |
| **NUR/최근 사용 전무<br />/Not Used Recently**          | 최근에 사용되지 않은 페이지를 교체하는 기법                  | 참조비트, 변경 비트 사용, LRU 시간 오버헤드 해결             |

</div> </details>

